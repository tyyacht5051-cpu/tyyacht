import express from 'express';
import { db } from '../db/database';

const router = express.Router();

// ì¸í„°íŽ˜ì´ìŠ¤ ì •ì˜
interface CruiseApplication {
  id: number;
  user_id: number;
  name: string;
  phone: string;
  email: string;
  experience_date: string;
  participants: number;
  special_requests: string;
  status: string;
  created_at: string;
  updated_at: string;
}

interface ExemptionApplication {
  id: number;
  user_id: number;
  name: string;
  phone: string;
  email: string;
  birth_date: string;
  gender: string;
  address: string;
  education_type: string;
  preferred_date: string;
  experience_years: number;
  boat_license_number: string;
  special_requests: string;
  status: string;
  created_at: string;
  updated_at: string;
}

interface EducationApplication {
  id: number;
  user_id: number;
  name: string;
  phone: string;
  email: string;
  birthDate: string;
  gender: string;
  address: string;
  license: string;
  courseType: string;
  preferredDates: string;
  discountEligibility: string;
  experience: string;
  motivation: string;
  status: string;
  created_at: string;
  updated_at: string;
}

// ì‚¬ìš©ìž ì¸ì¦ ë¯¸ë“¤ì›¨ì–´ (ì„ íƒì )
const authenticateUser = (req: any, res: any, next: any) => {
  const token = req.headers.authorization?.replace('Bearer ', '');
  console.log('ðŸ” authenticateUser - Token received:', {
    hasToken: !!token,
    tokenLength: token?.length || 0,
    tokenPreview: token ? token.substring(0, 20) + '...' : 'null'
  });
  
  if (token) {
    try {
      const jwt = require('jsonwebtoken');
      const secret = process.env.JWT_SECRET || 'tyyacht-jwt-secret-key-2024';
      console.log('ðŸ” JWT Secret being used:', secret);
      
      const decoded = jwt.verify(token, secret);
      console.log('âœ… Token decoded successfully:', { userId: decoded.userId });
      
      const user = db.prepare('SELECT * FROM users WHERE id = ?').get(decoded.userId) as any;
      console.log('ðŸ“Š User found in DB:', { 
        hasUser: !!user, 
        username: user?.username,
        userId: user?.id 
      });
      
      req.user = user;
    } catch (error: any) {
      console.error('âŒ JWT verification failed:', error?.message || error);
      // í† í°ì´ ìžˆì§€ë§Œ ìœ íš¨í•˜ì§€ ì•Šì€ ê²½ìš°ëŠ” ë¬´ì‹œí•˜ê³  ê³„ì† ì§„í–‰
    }
  } else {
    console.log('âš ï¸ No token provided in Authorization header');
  }
  
  console.log('ðŸ”„ authenticateUser result:', { hasReqUser: !!req.user });
  next();
};

// ê´€ë¦¬ìž ê¶Œí•œ í™•ì¸ ë¯¸ë“¤ì›¨ì–´
const authenticateAdmin = (req: any, res: any, next: any) => {
  const token = req.headers.authorization?.replace('Bearer ', '');
  if (!token) {
    return res.status(401).json({ error: 'No token provided' });
  }

  try {
    const jwt = require('jsonwebtoken');
    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'tyyacht-jwt-secret-key-2024');
    const user = db.prepare('SELECT * FROM users WHERE id = ?').get(decoded.userId) as any;
    
    if (!user || user.role !== 'admin') {
      return res.status(403).json({ error: 'Admin access required' });
    }
    
    req.user = user;
    next();
  } catch (error) {
    return res.status(401).json({ error: 'Invalid token' });
  }
};

// ============= ìŠ¹ì„ ì²´í—˜ ì‹ ì²­ API =============

// ìŠ¹ì„ ì²´í—˜ ì‹ ì²­ ì œì¶œ
router.post('/cruise', authenticateUser, (req: any, res) => {
  try {
    const {
      name,
      phone,
      email = '',
      experience_date,
      participants,
      special_requests = ''
    } = req.body;
    
    if (!name || !phone || !experience_date || !participants) {
      return res.status(400).json({ error: 'Required fields are missing' });
    }
    
    if (participants < 1 || participants > 20) {
      return res.status(400).json({ error: 'Participants must be between 1 and 20' });
    }
    
    const user_id = req.user ? req.user.id : null;
    
    const result = db.prepare(`
      INSERT INTO cruise_applications (user_id, name, phone, email, experience_date, participants, special_requests)
      VALUES (?, ?, ?, ?, ?, ?, ?)
    `).run(user_id, name, phone, email, experience_date, participants, special_requests);
    
    res.status(201).json({ 
      id: result.lastInsertRowid, 
      message: 'Cruise experience application submitted successfully' 
    });
  } catch (error) {
    console.error('Failed to submit cruise application:', error);
    res.status(500).json({ error: 'Failed to submit application' });
  }
});

// ìŠ¹ì„ ì²´í—˜ ì‹ ì²­ ëª©ë¡ ì¡°íšŒ (ê´€ë¦¬ìžë§Œ)
router.get('/cruise', authenticateAdmin, (req: any, res) => {
  try {
    const { status, limit = 50, offset = 0 } = req.query;
    
    let query = `
      SELECT ca.*, u.username as user_username 
      FROM cruise_applications ca 
      LEFT JOIN users u ON ca.user_id = u.id 
    `;
    const params: any[] = [];
    
    if (status) {
      query += ' WHERE ca.status = ?';
      params.push(status);
    }
    
    query += ' ORDER BY ca.created_at DESC LIMIT ? OFFSET ?';
    params.push(Number(limit), Number(offset));
    
    const applications = db.prepare(query).all(...params) as CruiseApplication[];
    
    res.json(applications);
  } catch (error) {
    console.error('Failed to fetch cruise applications:', error);
    res.status(500).json({ error: 'Failed to fetch applications' });
  }
});

// ìŠ¹ì„ ì²´í—˜ ì‹ ì²­ ìƒíƒœ ì—…ë°ì´íŠ¸ (ê´€ë¦¬ìžë§Œ)
router.put('/cruise/:id/status', authenticateAdmin, (req: any, res) => {
  try {
    const applicationId = parseInt(req.params.id);
    const { status } = req.body;
    
    if (!['pending', 'approved', 'rejected', 'completed'].includes(status)) {
      return res.status(400).json({ error: 'Invalid status' });
    }
    
    const result = db.prepare(`
      UPDATE cruise_applications 
      SET status = ?, updated_at = CURRENT_TIMESTAMP
      WHERE id = ?
    `).run(status, applicationId);
    
    if (result.changes === 0) {
      return res.status(404).json({ error: 'Application not found' });
    }
    
    res.json({ message: 'Application status updated successfully' });
  } catch (error) {
    console.error('Failed to update cruise application status:', error);
    res.status(500).json({ error: 'Failed to update status' });
  }
});

// ìŠ¹ì„ ì²´í—˜ ì‹ ì²­ ì‚­ì œ (ê´€ë¦¬ìžë§Œ)
router.delete('/cruise/:id', authenticateAdmin, (req: any, res) => {
  try {
    const applicationId = parseInt(req.params.id);
    
    const result = db.prepare(`
      DELETE FROM cruise_applications WHERE id = ?
    `).run(applicationId);
    
    if (result.changes === 0) {
      return res.status(404).json({ error: 'Application not found' });
    }
    
    res.json({ message: 'Application deleted successfully' });
  } catch (error) {
    console.error('Failed to delete cruise application:', error);
    res.status(500).json({ error: 'Failed to delete application' });
  }
});

// ìŠ¹ì„ ì²´í—˜ ì‹ ì²­ ì—‘ì…€ ë‹¤ìš´ë¡œë“œ (ê´€ë¦¬ìžë§Œ)
router.get('/cruise/export', authenticateAdmin, (req: any, res) => {
  try {
    const applications = db.prepare(`
      SELECT ca.*, u.username as user_username 
      FROM cruise_applications ca 
      LEFT JOIN users u ON ca.user_id = u.id 
      ORDER BY ca.created_at DESC
    `).all() as CruiseApplication[];
    
    // ì‹¤ì œë¡œëŠ” ì—‘ì…€ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì‚¬ìš©í•´ì•¼ í•˜ì§€ë§Œ, ì¼ë‹¨ JSONìœ¼ë¡œ ë°˜í™˜
    res.json(applications);
  } catch (error) {
    console.error('Failed to export cruise applications:', error);
    res.status(500).json({ error: 'Failed to export applications' });
  }
});

// ============= ë©´ì œêµìœ¡ ì‹ ì²­ API =============

// ë©´ì œêµìœ¡ ì‹ ì²­ ì œì¶œ
router.post('/exemption', authenticateUser, (req: any, res) => {
  try {
    const {
      name,
      phone,
      email,
      birthDate,
      gender,
      address,
      license,
      courseType,
      preferredDates,
      discountEligibility
    } = req.body;
    
    if (!name || !phone || !birthDate || !address || !courseType) {
      return res.status(400).json({ error: 'Required fields are missing' });
    }
    
    if (!['general', 'practical'].includes(courseType)) {
      return res.status(400).json({ error: 'Invalid course type' });
    }
    
    const user_id = req.user ? req.user.id : null;
    
    const result = db.prepare(`
      INSERT INTO exemption_applications (
        user_id, name, phone, email, birth_date, gender, address, 
        education_type, preferred_date, boat_license_number, special_requests
      )
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `).run(
      user_id, name, phone, email || '', birthDate, gender, address,
      courseType, preferredDates ? JSON.stringify(preferredDates) : null, 
      license || null, discountEligibility || null
    );
    
    res.status(201).json({ 
      id: result.lastInsertRowid, 
      message: 'ë©´ì œêµìœ¡ ì‹ ì²­ì´ ì ‘ìˆ˜ë˜ì—ˆìŠµë‹ˆë‹¤.' 
    });
  } catch (error) {
    console.error('Failed to submit exemption application:', error);
    res.status(500).json({ error: 'Failed to submit application' });
  }
});

// ë‚´ ë©´ì œêµìœ¡ ì‹ ì²­ ë‚´ì—­ ì¡°íšŒ (ë¡œê·¸ì¸í•œ ì‚¬ìš©ìž)
router.get('/my-exemption', authenticateUser, (req: any, res) => {
  try {
    if (!req.user) {
      return res.status(401).json({ error: 'Authentication required' });
    }

    const applications = db.prepare(`
      SELECT * FROM exemption_applications 
      WHERE user_id = ? 
      ORDER BY created_at DESC
    `).all(req.user.id) as ExemptionApplication[];

    res.json(applications);
  } catch (error) {
    console.error('Failed to fetch user exemption applications:', error);
    res.status(500).json({ error: 'Failed to fetch applications' });
  }
});

// ë©´ì œêµìœ¡ ì‹ ì²­ ëª©ë¡ ì¡°íšŒ (ê´€ë¦¬ìžë§Œ)
router.get('/exemption', authenticateAdmin, (req: any, res) => {
  try {
    const { status, education_type, limit = 50, offset = 0 } = req.query;
    
    let query = `
      SELECT ea.*, u.username as user_username 
      FROM exemption_applications ea 
      LEFT JOIN users u ON ea.user_id = u.id 
    `;
    const params: any[] = [];
    const conditions: string[] = [];
    
    if (status) {
      conditions.push('ea.status = ?');
      params.push(status);
    }
    
    if (education_type) {
      conditions.push('ea.education_type = ?');
      params.push(education_type);
    }
    
    if (conditions.length > 0) {
      query += ' WHERE ' + conditions.join(' AND ');
    }
    
    query += ' ORDER BY ea.created_at DESC LIMIT ? OFFSET ?';
    params.push(Number(limit), Number(offset));
    
    const applications = db.prepare(query).all(...params) as ExemptionApplication[];
    
    res.json(applications);
  } catch (error) {
    console.error('Failed to fetch exemption applications:', error);
    res.status(500).json({ error: 'Failed to fetch applications' });
  }
});

// ë©´ì œêµìœ¡ ì‹ ì²­ ìƒíƒœ ì—…ë°ì´íŠ¸ (ê´€ë¦¬ìžë§Œ)
router.patch('/exemption/:id/status', authenticateAdmin, (req: any, res) => {
  try {
    const applicationId = parseInt(req.params.id);
    const { status } = req.body;
    
    if (!['pending', 'approved', 'rejected'].includes(status)) {
      return res.status(400).json({ error: 'Invalid status' });
    }
    
    const result = db.prepare(`
      UPDATE exemption_applications 
      SET status = ?, updated_at = CURRENT_TIMESTAMP
      WHERE id = ?
    `).run(status, applicationId);
    
    if (result.changes === 0) {
      return res.status(404).json({ error: 'Application not found' });
    }
    
    res.json({ message: 'Application status updated successfully' });
  } catch (error) {
    console.error('Failed to update exemption application status:', error);
    res.status(500).json({ error: 'Failed to update status' });
  }
});

// ë©´ì œêµìœ¡ ì‹ ì²­ í†µê³„ (ê´€ë¦¬ìžë§Œ)
router.get('/exemption/stats', authenticateAdmin, (req: any, res) => {
  try {
    // ê¸°ë³¸ í†µê³„
    const totalApplications = db.prepare('SELECT COUNT(*) as count FROM exemption_applications').get() as any;
    const pendingApplications = db.prepare('SELECT COUNT(*) as count FROM exemption_applications WHERE status = ?').get('pending') as any;
    const approvedApplications = db.prepare('SELECT COUNT(*) as count FROM exemption_applications WHERE status = ?').get('approved') as any;
    
    // ì´ë²ˆ ë‹¬ í†µê³„
    const thisMonth = db.prepare(`
      SELECT COUNT(*) as count FROM exemption_applications 
      WHERE strftime('%Y-%m', created_at) = strftime('%Y-%m', 'now')
    `).get() as any;
    
    res.json({
      total: totalApplications.count,
      pending: pendingApplications.count,
      approved: approvedApplications.count,
      thisMonth: thisMonth.count
    });
  } catch (error) {
    console.error('Failed to get exemption application stats:', error);
    res.status(500).json({ error: 'Failed to get stats' });
  }
});

// ë‚ ì§œë³„ ì‹ ì²­ìž ìˆ˜ ì¡°íšŒ (ê³µê°œ) - ìŠ¹ì¸ëœ ì‹ ì²­ì„œë§Œ ì¹´ìš´íŠ¸
router.get('/exemption/counts/:month', (req: any, res) => {
  try {
    const { month } = req.params; // í˜•ì‹: 2024-12
    
    // ìŠ¹ì¸ëœ ì‹ ì²­ì„œë§Œ ê°€ì ¸ì˜¤ê¸°
    const applications = db.prepare(`
      SELECT preferred_date, COUNT(*) as count
      FROM exemption_applications 
      WHERE preferred_date IS NOT NULL 
      AND status = 'approved'
      GROUP BY preferred_date
    `).all() as any[];
    
    const dateCounts: { [key: string]: number } = {};
    
    applications.forEach(app => {
      try {
        // preferred_dateê°€ JSON ë°°ì—´ì¸ì§€ ë‹¨ì¼ ë¬¸ìžì—´ì¸ì§€ í™•ì¸
        let dates = [];
        if (typeof app.preferred_date === 'string') {
          try {
            // JSON íŒŒì‹± ì‹œë„
            dates = JSON.parse(app.preferred_date);
          } catch {
            // JSONì´ ì•„ë‹ˆë©´ ë‹¨ì¼ ë‚ ì§œë¡œ ì²˜ë¦¬
            dates = [app.preferred_date];
          }
        }
        
        if (Array.isArray(dates)) {
          dates.forEach((date: string) => {
            if (date && date.startsWith(month)) {
              dateCounts[date] = (dateCounts[date] || 0) + app.count;
            }
          });
        }
      } catch (error) {
        console.error('Error processing preferred_date:', error);
      }
    });
    
    res.json({ 
      counts: dateCounts,
      totalApprovedApplications: applications.reduce((sum, app) => sum + app.count, 0)
    });
  } catch (error) {
    console.error('Failed to get exemption application counts:', error);
    res.status(500).json({ error: 'Failed to get counts' });
  }
});

// ë©´ì œêµìœ¡ ì‹ ì²­ ì—‘ì…€ ë‹¤ìš´ë¡œë“œ (ê´€ë¦¬ìžë§Œ)
router.get('/exemption/export', authenticateAdmin, (req: any, res) => {
  try {
    const applications = db.prepare(`
      SELECT ea.*, u.username as user_username 
      FROM exemption_applications ea 
      LEFT JOIN users u ON ea.user_id = u.id 
      ORDER BY ea.created_at DESC
    `).all() as ExemptionApplication[];
    
    // ì‹¤ì œë¡œëŠ” ì—‘ì…€ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì‚¬ìš©í•´ì•¼ í•˜ì§€ë§Œ, ì¼ë‹¨ JSONìœ¼ë¡œ ë°˜í™˜
    res.json(applications);
  } catch (error) {
    console.error('Failed to export exemption applications:', error);
    res.status(500).json({ error: 'Failed to export applications' });
  }
});

// ============= ìš”íŠ¸êµìœ¡ ì‹ ì²­ API =============

// ìš”íŠ¸êµìœ¡ ì‹ ì²­ ì œì¶œ
router.post('/education', authenticateUser, (req: any, res) => {
  try {
    const {
      name,
      phone,
      email,
      birthDate,
      gender,
      address,
      license,
      courseType,
      preferredDates,
      discountEligibility,
      experience,
      motivation
    } = req.body;
    
    if (!name || !phone || !email || !birthDate || !gender || !address || !courseType) {
      return res.status(400).json({ error: 'Required fields are missing' });
    }
    
    if (!['cruise', 'dinghy'].includes(courseType)) {
      return res.status(400).json({ error: 'Invalid course type' });
    }
    
    const user_id = req.user ? req.user.id : null;
    
    const result = db.prepare(`
      INSERT INTO education_applications (
        user_id, name, phone, email, birth_date, gender, address, 
        license, course_type, preferred_dates, discount_eligibility, experience, motivation
      )
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `).run(
      user_id, name, phone, email, birthDate, gender, address,
      license || '', courseType, preferredDates ? JSON.stringify(preferredDates) : null,
      discountEligibility || '', experience || 'none', motivation || ''
    );
    
    res.status(201).json({ 
      id: result.lastInsertRowid, 
      message: 'ìš”íŠ¸êµìœ¡ ì‹ ì²­ì´ ì ‘ìˆ˜ë˜ì—ˆìŠµë‹ˆë‹¤.' 
    });
  } catch (error) {
    console.error('Failed to submit education application:', error);
    res.status(500).json({ error: 'Failed to submit application' });
  }
});

// ë‚´ ìš”íŠ¸êµìœ¡ ì‹ ì²­ ë‚´ì—­ ì¡°íšŒ (ë¡œê·¸ì¸í•œ ì‚¬ìš©ìž)
router.get('/my-education', authenticateUser, (req: any, res) => {
  try {
    if (!req.user) {
      return res.status(401).json({ error: 'Authentication required' });
    }

    const applications = db.prepare(`
      SELECT * FROM education_applications 
      WHERE user_id = ? 
      ORDER BY created_at DESC
    `).all(req.user.id) as EducationApplication[];

    res.json(applications);
  } catch (error) {
    console.error('Failed to fetch user education applications:', error);
    res.status(500).json({ error: 'Failed to fetch applications' });
  }
});

// ìš”íŠ¸êµìœ¡ ì‹ ì²­ ëª©ë¡ ì¡°íšŒ (ê´€ë¦¬ìžë§Œ)
router.get('/education', authenticateAdmin, (req: any, res) => {
  try {
    const { status, courseType, limit = 50, offset = 0 } = req.query;
    
    let query = `
      SELECT ea.*, u.username as user_username 
      FROM education_applications ea 
      LEFT JOIN users u ON ea.user_id = u.id 
    `;
    const params: any[] = [];
    const conditions: string[] = [];
    
    if (status) {
      conditions.push('ea.status = ?');
      params.push(status);
    }
    
    if (courseType) {
      conditions.push('ea.course_type = ?');
      params.push(courseType);
    }
    
    if (conditions.length > 0) {
      query += ' WHERE ' + conditions.join(' AND ');
    }
    
    query += ' ORDER BY ea.created_at DESC LIMIT ? OFFSET ?';
    params.push(Number(limit), Number(offset));
    
    const applications = db.prepare(query).all(...params) as EducationApplication[];
    
    res.json(applications);
  } catch (error) {
    console.error('Failed to fetch education applications:', error);
    res.status(500).json({ error: 'Failed to fetch applications' });
  }
});

// ìš”íŠ¸êµìœ¡ ì‹ ì²­ ìƒíƒœ ì—…ë°ì´íŠ¸ (ê´€ë¦¬ìžë§Œ)
router.patch('/education/:id/status', authenticateAdmin, (req: any, res) => {
  try {
    const applicationId = parseInt(req.params.id);
    const { status } = req.body;
    
    if (!['pending', 'approved', 'rejected'].includes(status)) {
      return res.status(400).json({ error: 'Invalid status' });
    }
    
    const result = db.prepare(`
      UPDATE education_applications 
      SET status = ?, updated_at = CURRENT_TIMESTAMP
      WHERE id = ?
    `).run(status, applicationId);
    
    if (result.changes === 0) {
      return res.status(404).json({ error: 'Application not found' });
    }
    
    res.json({ message: 'Application status updated successfully' });
  } catch (error) {
    console.error('Failed to update education application status:', error);
    res.status(500).json({ error: 'Failed to update status' });
  }
});

// ìš”íŠ¸êµìœ¡ ì‹ ì²­ ì‚­ì œ (ê´€ë¦¬ìžë§Œ)
router.delete('/education/:id', authenticateAdmin, (req: any, res) => {
  try {
    const applicationId = parseInt(req.params.id);
    
    const result = db.prepare(`
      DELETE FROM education_applications WHERE id = ?
    `).run(applicationId);
    
    if (result.changes === 0) {
      return res.status(404).json({ error: 'Application not found' });
    }
    
    res.json({ message: 'Application deleted successfully' });
  } catch (error) {
    console.error('Failed to delete education application:', error);
    res.status(500).json({ error: 'Failed to delete application' });
  }
});

// ìš”íŠ¸êµìœ¡ ì‹ ì²­ í†µê³„ (ê´€ë¦¬ìžë§Œ)
router.get('/education/stats', authenticateAdmin, (req: any, res) => {
  try {
    // ê¸°ë³¸ í†µê³„
    const totalApplications = db.prepare('SELECT COUNT(*) as count FROM education_applications').get() as any;
    const pendingApplications = db.prepare('SELECT COUNT(*) as count FROM education_applications WHERE status = ?').get('pending') as any;
    const approvedApplications = db.prepare('SELECT COUNT(*) as count FROM education_applications WHERE status = ?').get('approved') as any;
    
    // ì´ë²ˆ ë‹¬ í†µê³„
    const thisMonth = db.prepare(`
      SELECT COUNT(*) as count FROM education_applications 
      WHERE strftime('%Y-%m', created_at) = strftime('%Y-%m', 'now')
    `).get() as any;
    
    res.json({
      total: totalApplications.count,
      pending: pendingApplications.count,
      confirmed: approvedApplications.count,
      thisMonth: thisMonth.count
    });
  } catch (error) {
    console.error('Failed to get education application stats:', error);
    res.status(500).json({ error: 'Failed to get stats' });
  }
});

// ìš”íŠ¸êµìœ¡ ì‹ ì²­ ì—‘ì…€ ë‹¤ìš´ë¡œë“œ (ê´€ë¦¬ìžë§Œ)
router.get('/education/export', authenticateAdmin, (req: any, res) => {
  try {
    const applications = db.prepare(`
      SELECT ea.*, u.username as user_username 
      FROM education_applications ea 
      LEFT JOIN users u ON ea.user_id = u.id 
      ORDER BY ea.created_at DESC
    `).all() as EducationApplication[];
    
    // ì‹¤ì œë¡œëŠ” ì—‘ì…€ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì‚¬ìš©í•´ì•¼ í•˜ì§€ë§Œ, ì¼ë‹¨ JSONìœ¼ë¡œ ë°˜í™˜
    res.json(applications);
  } catch (error) {
    console.error('Failed to export education applications:', error);
    res.status(500).json({ error: 'Failed to export applications' });
  }
});

// ============= í†µê³„ API =============

// ì‹ ì²­ í†µê³„ (ê´€ë¦¬ìžë§Œ)
router.get('/stats', authenticateAdmin, (req: any, res) => {
  try {
    // ìŠ¹ì„ ì²´í—˜ í†µê³„
    const cruiseStats = db.prepare(`
      SELECT 
        status,
        COUNT(*) as count
      FROM cruise_applications 
      GROUP BY status
    `).all();
    
    // ë©´ì œêµìœ¡ í†µê³„
    const exemptionStats = db.prepare(`
      SELECT 
        status,
        education_type,
        COUNT(*) as count
      FROM exemption_applications 
      GROUP BY status, education_type
    `).all();
    
    // ìµœê·¼ 7ì¼ê°„ ì‹ ì²­ ìˆ˜
    const recentApplications = db.prepare(`
      SELECT 
        DATE(created_at) as date,
        'cruise' as type,
        COUNT(*) as count
      FROM cruise_applications 
      WHERE created_at >= DATE('now', '-7 days')
      GROUP BY DATE(created_at)
      
      UNION ALL
      
      SELECT 
        DATE(created_at) as date,
        'exemption' as type,
        COUNT(*) as count
      FROM exemption_applications 
      WHERE created_at >= DATE('now', '-7 days')
      GROUP BY DATE(created_at)
      
      ORDER BY date DESC
    `).all();
    
    res.json({
      cruise: cruiseStats,
      exemption: exemptionStats,
      recent: recentApplications
    });
  } catch (error) {
    console.error('Failed to fetch application stats:', error);
    res.status(500).json({ error: 'Failed to fetch stats' });
  }
});

export default router;